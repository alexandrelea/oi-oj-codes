**题源**：[Codeforces-1904C](https://vjudge.net/problem/CodeForces-1904C#author=GPT_zh).

给你一个由 $n$ 个正整数组成的数组 $a$。在一次操作中，你必须选择一些 $(i,j)$，使得 $1\leq i<j\leq|a|$，然后将 $|a_i-a_j|$ 附加到 $a$ 的末尾（即将 $n$ 增加 $1$ 并将 $a_n$ 设置为 $|a_i-a_j|$）。你的任务是在执行 $k$ 次操作后，最小化并打印出 $a$ 的最小值。

**解**，容易发现，对于 $k\ge 3$，答案为 $0$，可以添加两个（对于任意 $i,j$）$|a_i-a_j|$，并让它们相减得到 $0$。故考虑 $k\le 2$。

当 $k=1$ 时，答案要么在 $a$ 中，要么在 $|a_i-a_j|$ 中。则先对 $a$ 排序，然后求两者间最小值。

当 $k=2$ 时，对 $i,j$ 暴力。设 $v=|a_i-a_j|$，我们要找离 $v$ 最接近的 $a_k$（和 $a_k+1$，理论上它们两面包夹 $v$），最后把答案更新成这个。

时间复杂度为 $O(n^2\log_2n)$。

---

**题源**：[Codeforces-1862D](https://vjudge.net/problem/CodeForces-1862D#author=GPT_zh).

你可以使用任意两个数字组成一个二元组。

两个二元组被认为是不同的，那么这两个二元组中的元素在经过调换顺序后不同。例如，$\{1,2\}=\{2,1\},\{1,1\}\ne\{1,2\}$。

如果你选择了数字 $1,1,2$，那么你只能得到两个二元组：$\{1,1\},\{1,2\}$。

现在请你求出至少要**多少个数字**才能**刚好**得到 $n$ 个不同的二元组。

**解**：首先，设我们可以用 $k$ 个不同的单个数字凑一下 $n$，即用 $k$ 个不同数字组成的大小为 $2$ 得二元组个数等于 $n$，即首先解方程 $\binom{k}{2}=\dfrac{k(k-1)}{2}=n$ 得（舍去负的根） $k=\dfrac{1+\sqrt{8n+1}}{2}$，显然需要先 $\lfloor k\rfloor\to k$，设 $h=\binom k2$。于是我们就剩下了 $n-h$ 个需要补齐的二元组。用 $n-h$ 个相同的数字凑够即可。

答案为 $n-h+k$。时间复杂度为 $O(1)$。

---
**题源**：[Codeforces-1986D](https://vjudge.net.cn/problem/codeforces-1986d#author=GPT_zh)。

将一段长为 $n$ 的数字串中插入 $n-2$ 个乘号或者加号使得最终的答案最小。$n\le 20$。

**解**：设数字串为 $w_{1\cdots n}$，我们用动态规划来解这个问题。设 $f(p,q,u)$ 代表从 $w[p\cdots q]$ 中被切割产生的最小数值，而 $u$ 代表是否保留一段长为 $2$ 的数字串。

那么，对于不需要保留两个数字的段，状态转移方程如下：

$$f(p,q,0)=\min_{k=p}^{q-1}\{f(p,k,0)f(k+1,q,0),f(p,k,0)+f(k+1,q,0)\}$$

然而，对于需要保留两个数字的段，状态转移方程有点费力：

$$f(p,q,1)=\min_{k=p}^{q-1}\min_{u=0}^1\{f(p,k,u)f(k+1,q,1-u),f(p,k,u)+f(k+1,q,1-u)\}$$

而边界条件也是很容易的：$f(p,p,0)=w_p,f(p,p+1,1)=10w_p+w_{p+1}$。注意对越界条件的判断。用记忆化搜索即可。