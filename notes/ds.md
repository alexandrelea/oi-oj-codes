标题：部分数据结构

# 线性数据结构

线性数据结构的最直接的两个结构就是数组和链表。

数组就是一排数字连着存储，链表就是只保存通往上一个或下一个数据的节点和当前节点的数据。

众所周知，数组可以直接通过下标访问数据，而链表需要许多便利；但是如果删除或添加数据，如果数组的话就需要大规模移动数据，链表就可以直接修改上一个或下一个数据在哪里，直接丢弃不需要的数据。

## 栈和队列

栈和队列都非常简单，可以通过数组和链表直接实现。

栈，就是只允许数据有一个出入口，而队列则是两个。

队列需要明确数据出入的出入口（对，数据由队头弹出，由队尾进入，并且存在数据可以从首尾两端进出的队列），而栈只需要栈顶直接进行数据压入和弹出。

递归时采用的数据结构是栈。

通常在实现队列时为了节省空间可以使用循环下标的队列。

# 树型数据结构

~~该死的树！我发泄完了。~~

## 基本的树

基本的树非常简单，基本就是一个父级节点接上多个子节点，如果不固定根节点的话这棵树甚至可能是多种形状，不过其拓扑结构是一致的。

一种极为特殊的树是二叉树，因为所有的父级节点最多只能有两个子节点。

通常对于树的实现有链式法和下表固定计算法。由于后者的空间浪费较大，故而在采用完全二叉树的数据结构中普遍应用，而链式法可以动态开点。

## 堆

堆分为大根堆和小根堆两种，其子节点都大于或者小于其父节点。我不明白的是，小根堆的子节点都大于父节点，而大根堆的子节点都小于父节点。

这个算法可以通过 $\mathrm O(\log n)$ 来插入或者删除元素，因此是多种算法中快速求最大值的好东西。

由于堆的优良性质，优先队列就以堆为内里。因而，我们可以使用下面的方式定义大根堆/小根堆：

```cpp
priority_queue<int,vector<int>,less<int>> pq; //小根堆
priority_queue<int,vector<int>,greater<int>> pq; //大根堆
```

当然，使用 pbds 也不是不行。

## Fenwick 树

这种东西也叫做树状数组，不过我们没有功夫去给它建一棵树，因为我们不需要。

它是求前缀和的利器。

怎么求前缀和呢？

众所周知，我们可以将数组进行二进制合并，例如 $1-10$：

```plaintext
-----------------------
----------- -----------
----- ----- ----- ----- -----
-- -- -- -- -- -- -- -- -- --
01 02 03 04 05 06 07 08 09 10
```

然后，我们为了节省空间，删除一些节点：

```plaintext
-----------------------
-----------
-----       -----       -----
--    --    --    --    -- 
01 02 03 04 05 06 07 08 09 10
```

好的下面我们就组织完了一棵树。为了搞明白我们到底如何利用这棵树，我们将编号变成二进制：

```plaintext
---------------------------------------
------------------- 
---------           ---------           ---------
----      ----      ----      ----      ----
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010
```

看上去似乎没有多少规律。

不过，如果我们求一些前缀和，我们就有一些好戏看了：

```plaintext
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
------------------- 
---------           ---------           xxxxxxxxx
----      ----      ----      ----      ---- 
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(10)
```

```plaintext
---------------------------------------
xxxxxxxxxxxxxxxxxxx 
---------           ---------           ---------
----      ----      xxxx      ----      ---- 
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(5)
```

```plaintext
---------------------------------------
xxxxxxxxxxxxxxxxxxx 
---------           xxxxxxxxx           ---------
----      ----      ----      xxxx      ---- 
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010
(7)
```

我们可以看出，我们可以通过每次拿掉最后的一个 $1$ 来求和。

那么我们首先需要找到某个整数的最后一位，同时附上部分定义：

```cpp
int psum[SIZE],n;
int eje(int x){
    return x&(-x);
}
```

好的我们就利用完计算机的补码，我们可以完成前缀和的内容：

```cpp
int summ(int x){
    int ans=0;
    for(;x!=0;x-=eje(x)) ans+=bit[x];
    return ans;
}
```

这个前缀和很快，时间复杂度近似为 $\mathrm O(\log n)$。

好的，下面就是前缀加了。我们可以在前缀上进行加法，例如我们在某个地方上做加法，而后我们再次观察需要影响的地方：

```plaintext
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
------------------- 
---------           xxxxxxxxx           ---------
----      ----      xxxx      ----      ----
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(5)
```

```plaintext
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxx 
---------           ---------           ---------
----      xxxx      ----      ----      ----
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(3)
```

而后我们可以将单个数进行修改的方式再次写成代码，方法就是加上最后一个 $1$：

```cpp
void addd(int x,int v){
    for(;x<=n;x+=eje(x)) bit[x]+=v;
}
```

求和的速度同样很快，速度为 $\mathrm O(\log n)$。

好的，那么这个东西就叫作树状数组。

树状数组最大的作用就是求前缀和，以及通过前缀和求区间和。

另外，绝对不要把树状数组存储的对象搞混！树状数组存储的是前缀和，但是不能在树状数组直接修改差分！

## 线段树

最折磨人的数据结构。

首先，线段树采用拆的方式，不过是一开始拆完并且不参考二进制，因而线段树长得像这样：

```plaintext
-----------------------------
-------------- --------------
----- -------- ----- --------
-- -- ----- -- -- -- ----- --
      -- --          -- --
01 02 03 04 05 06 07 08 09 10
```

那么，如果我们要点修改的话，我们就需要 $\mathrm O(\log n)$ 的复杂度找到叶子节点，而后通过上传更新，不过采用这个数据结构有一个好处：区间查询！

例如我们要查找部分的区间我们就只需要查询部分节点并合并它们：

```plaintext
-----------------------------
-------------- --------------
----- xxxxxxxx xxxxx --------
-- xx ----- -- -- -- ----- --
      -- --          -- --
01 02 03 04 05 06 07 08 09 10

(02-07)
```

```plaintext
-----------------------------
-------------- xxxxxxxxxxxxxx
----- -------- ----- --------
-- -- ----- xx -- -- ----- --
      -- xx          -- --
01 02 03 04 05 06 07 08 09 10

(04-10)
```

这样我们便只需要查询部分节点个数来获知完整的答案。

那么，应用这个不需要全部计算到底的思想，我们就可以暂留不需要更新的节点，只在它这里保留一个标记。

这只是一个初步的思想，而线段树的可扩展性很大，因此这里就先不多说了罢。

这里需要留下一点点代码，因为这个东西太可怕了，细节巨多且不好写。这里仅仅以求和为例。

```cpp
const int SIZE=1e5+10;
int summ[4*SIZE],lass[4*SIZE],
```

## 威廉树

这是汤浩的树，他的代码称“威廉树”，那么……名字就不用说了。

以下是他的数据结构的似乎是样子是这样的（病~~娇的~~句~~子~~)：

```plaintext
           1
          / \
         |   |
         /   \
        2     3
       / \   / \
      /   \ /   \
     |    | |    |
     4    5 6    7
```

好的，边和点都是有权的。当然，点权初始值是 $0$，但是边权嘛，我们需要一个序列，来让我们这个好吃的数据结构做例子：

```plaintext
8 6 4 3 7 1 5
```

好，那么我们可以定出边权（当然点权我们就隐藏，但是保留相对位置）：

```plaintext
           0
          / \
         14 18
         /   \
        0     0
       / \   / \
      13 20 15 20
      |   | |   |
      0   0 0   0
```

可以看出，对于每个点 $V_x$，以及它的父亲 $V_f$，它们的边权 $E_{V_x,V_f}=\sum_{k=f}^xA_k$。（看得懂吧 :-）而后，我们的前缀和就好算了，可以直接把某个点到根节点的边权加起来。这当然是显然的。

好的那么我们要开始修改点了：啊？等下，等下我先去看[原文](https://www.luogu.com.cn/discuss/638729?page=1&sort=time-d) :-(……