标题：部分数据结构

# 线性数据结构

线性数据结构的最直接的两个结构就是数组和链表。

数组就是一排数字连着存储，链表就是只保存通往上一个或下一个数据的节点和当前节点的数据。

众所周知，数组可以直接通过下标访问数据，而链表需要许多便利；但是如果删除或添加数据，如果数组的话就需要大规模移动数据，链表就可以直接修改上一个或下一个数据在哪里，直接丢弃不需要的数据。

## 栈和队列

栈和队列都非常简单，可以通过数组和链表直接实现。

栈，就是只允许数据有一个出入口，而队列则是两个。

队列需要明确数据出入的出入口（对，数据由队头弹出，由队尾进入，并且存在数据可以从首尾两端进出的队列），而栈只需要栈顶直接进行数据压入和弹出。

递归时采用的数据结构是栈。

通常在实现队列时为了节省空间可以使用循环下标的队列。

# 树型数据结构

~~该死的树！我发泄完了。~~

## 基本的树

基本的树非常简单，基本就是一个父级节点接上多个子节点，如果不固定根节点的话这棵树甚至可能是多种形状，不过其拓扑结构是一致的。

一种极为特殊的树是二叉树，因为所有的父级节点最多只能有两个子节点。

通常对于树的实现有链式法和下表固定计算法。由于后者的空间浪费较大，故而在采用完全二叉树的数据结构中普遍应用，而链式法可以动态开点。

## 堆

堆分为大根堆和小根堆两种，其子节点都大于或者小于其父节点。我不明白的是，小根堆的子节点都大于父节点，而大根堆的子节点都小于父节点。

这个算法可以通过 $\mathrm O(\log n)$ 来插入或者删除元素，因此是多种算法中快速求最大值的好东西。

由于堆的优良性质，优先队列就以堆为内里。因而，我们可以使用下面的方式定义大根堆/小根堆：

```cpp
priority_queue<int,vector<int>,less<int>> pq; //小根堆
priority_queue<int,vector<int>,greater<int>> pq; //大根堆
```

当然，使用 pbds 也不是不行。

## Fenwick 树

这种东西也叫做树状数组，不过我们没有功夫去给它建一棵树，因为我们不需要。

它是求前缀和的利器。

怎么求前缀和呢？

众所周知，我们可以将数组进行二进制合并，例如 $1-10$：

```plaintext
-----------------------
----------- -----------
----- ----- ----- ----- -----
-- -- -- -- -- -- -- -- -- --
01 02 03 04 05 06 07 08 09 10
```

然后，我们为了节省空间，删除一些节点：

```plaintext
-----------------------
-----------
-----       -----       -----
--    --    --    --    -- 
01 02 03 04 05 06 07 08 09 10
```

好的下面我们就组织完了一棵树。为了搞明白我们到底如何利用这棵树，我们将编号变成二进制：

```plaintext
---------------------------------------
------------------- 
---------           ---------           ---------
----      ----      ----      ----      ----
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010
```

看上去似乎没有多少规律。

不过，如果我们求一些前缀和，我们就有一些好戏看了：

```plaintext
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
------------------- 
---------           ---------           xxxxxxxxx
----      ----      ----      ----      ---- 
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(10)
```

```plaintext
---------------------------------------
xxxxxxxxxxxxxxxxxxx 
---------           ---------           ---------
----      ----      xxxx      ----      ---- 
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(5)
```

```plaintext
---------------------------------------
xxxxxxxxxxxxxxxxxxx 
---------           xxxxxxxxx           ---------
----      ----      ----      xxxx      ---- 
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010
(7)
```

我们可以看出，我们可以通过每次拿掉最后的一个 $1$ 来求和。

那么我们首先需要找到某个整数的最后一位，同时附上部分定义：

```cpp
int psum[SIZE],n;
int eje(int x){
    return x&(-x);
}
```

好的我们就利用完计算机的补码，我们可以完成前缀和的内容：

```cpp
int summ(int x){
    int ans=0;
    for(;x!=0;x-=eje(x)) ans+=bit[x];
    return ans;
}
```

这个前缀和很快，时间复杂度近似为 $\mathrm O(\log n)$。

好的，下面就是前缀加了。我们可以在前缀上进行加法，例如我们在某个地方上做加法，而后我们再次观察需要影响的地方：

```plaintext
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
------------------- 
---------           xxxxxxxxx           ---------
----      ----      xxxx      ----      ----
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(5)
```

```plaintext
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxx 
---------           ---------           ---------
----      xxxx      ----      ----      ----
0001 0010 0011 0100 0101 0110 0111 1000 1001 1010

(3)
```

而后我们可以将单个数进行修改的方式再次写成代码，方法就是加上最后一个 $1$：

```cpp
void addd(int x,int v){
    for(;x<=n;x+=eje(x)) bit[x]+=v;
}
```

求和的速度同样很快，速度为 $\mathrm O(\log n)$。

好的，那么这个东西就叫作树状数组。

树状数组最大的作用就是求前缀和，以及通过前缀和求区间和。

另外，绝对不要把树状数组存储的对象搞混！树状数组存储的是前缀和，但是不能在树状数组直接修改差分！

## 线段树

最折磨人的数据结构。

首先，线段树采用拆的方式，不过是一开始拆完并且不参考二进制，因而线段树长得像这样：

```plaintext
-----------------------------
-------------- --------------
----- -------- ----- --------
-- -- ----- -- -- -- ----- --
      -- --          -- --
01 02 03 04 05 06 07 08 09 10
```

那么，如果我们要点修改的话，我们就需要 $\mathrm O(\log n)$ 的复杂度找到叶子节点，而后通过上传更新，不过采用这个数据结构有一个好处：区间查询！

例如我们要查找部分的区间我们就只需要查询部分节点并合并它们：

```plaintext
-----------------------------
-------------- --------------
----- xxxxxxxx xxxxx --------
-- xx ----- -- -- -- ----- --
      -- --          -- --
01 02 03 04 05 06 07 08 09 10

(02-07)
```

```plaintext
-----------------------------
-------------- xxxxxxxxxxxxxx
----- -------- ----- --------
-- -- ----- xx -- -- ----- --
      -- xx          -- --
01 02 03 04 05 06 07 08 09 10

(04-10)
```

这样我们便只需要查询部分节点个数来获知完整的答案。

那么，应用这个不需要全部计算到底的思想，我们就可以暂留不需要更新的节点，只在它这里保留一个标记。

这只是一个初步的思想，而线段树的可扩展性很大，因此这里就先不多说了罢。

这里需要留下一点点代码，因为这个东西太可怕了，细节巨多且不好写。这里仅仅以求和为例。

```cpp
const int SIZE=1e5+10;
int a[SIZE],n;
int sumv[SIZE*4],tagv[SIZE*4],ivl[SIZE*4],ivr[SIZE*4];
void build(int cur,int beg,int end){
    ivl[cur]=beg,ivr[cur]=end;
    if(beg==end) sumv[cur]=a[beg];
    else{
        int mid=beg+(end-beg)/2;
        build(cur*2,beg,mid);
        build(cur*2+1,mid+1,end);
        sumv[cur]=sumv[cur*2]+sumv[cur*2+1];
    }
}
void pushdown(int cur){
    if(tagv[cur]==0) return;
    int lch=cur*2,rch=cur*2+1,tag=tagv[cur];
    tagv[lch]+=tag,tagv[rch]+=tag;
    sumv[lch]+=tag*(ivr[lch]-ivl[lch]+1),sumv[rch]+=tag*(ivr[rch]-ivl[rch]+1);
    tagv[cur]=0;
}
int query(int cur,int qul,int qur){
    if(qul<=ivl[cur]&&ivr[cur]<=qur) return sumv[cur];
    pushdown(cur);
    int qry=0;
    if(qul<=ivr[cur*2]) qry+=query(cur*2,qul,qur);
    if(ivl[cur*2+1]<=qur) qry+=query(cur*2+1,qul,qur);
    return qry;
}
void modify(int cur,int mol,int mor,int mov){
    if(mol<=ivl[cur]&&ivr[cur]<=mor) sumv[cur]+=mov*(ivr[cur]-ivl[cur]+1),tagv[cur]+=mov;
    else{
        pushdown(cur);
        if(mol<=ivr[cur*2]) modify(cur*2,mol,mor,mov);
        if(ivl[cur*2+1]<=mor) modify(cur*2+1,mol,mor,mov);
        sumv[cur]=sumv[cur*2]+sumv[cur*2+1];
    }
}
```

## 平衡树

这个平衡树是一种不好吃的东西。

平衡树的基础是二叉查找树，即 BST。

BST的基础操作即插入和删除。插入时可以赋予节点权值，左侧为比权值小的，右侧为比权值大的。例如我们按顺序插入 1 9 2 6 0 8 1 7：

```plaintext
     1(+)
    / \
   0   9
      /
     2
      \
       6
        \
         8
        /
       7
```

可以看到，这种东西很容易形成长链，然后时间复杂度就爆炸了。

我们需要一种可以将二叉查找树平衡的方法。例如，我们将下面的树进行右旋：

```plaintext
     a
    / \
   b   c
  / \
 d   e

d<b<e<a<c
```

首先，置 `a` 的左节点为 `e`。

```plaintext
     a
     |\
   b | c
  /  |
 d   e
```

而后，置 `b` 的右节点为 `a`。

```plaintext
     b
    / \
   d   a
      / \
     e   c

d<b<e<a<c
```

仍然满足原来的树的条件。

然后，我们需要找出是否旋转的方式。

### Splay

这种东西是伸展树，这棵该死的玩意暂时不说。（太他妈难嘣了）

### Treap

这是树堆，通过在树上满足堆的性质，所以叫做树堆。

树堆的每个节点包含两个值：权值和堆值，权值需要满足 BST，而堆值满足堆的要求。因为旋转对于BST的性质不会做出影响，因而可以通过旋转满足堆的性质；又因为堆值是随机生成的因此可以基本满足平衡的要求。

首先是插入，插入时需要满足BST，并且对于非堆的节点做出更改。例如，插入 `3 1 4 5 9 2 6`，我们就有（这里随机的堆值是 `2 8 3 6 7 0 9`，并且堆的儿子比堆的父亲大）

```plaintext
3(2)
```

```plaintext
    3(2)
   /
 1(8)
```

```plaintext
    3(2)
   /    \
 1(8)  4(3)
```

```plaintext
    3(2)
   /    \
 1(8)  4(3)
          \
         5(6)
```

```plaintext
    3(2)
   /    \
 1(8)  4(3)
          \
         5(6)
            \
           9(7)
```

```plaintext
    3(2)
   /    \
 1(8)  4(3)
   \      \
  2(0)   5(6)
            \
           9(7)

(Here is not specify the request. So we must rotate the tree.)

    3(2)
      | \
 1(8) | 4(3)
   \  |   \
   2(0)  5(6)
            \
           9(7)

  2(0)
  /  \
1(8) 3(2)
        \
        4(3)
          \
          5(6)
            \
           9(7)
```

```plaintext
  2(0)
  /  \
1(8) 3(2)
        \
        4(3)
          \
          5(6)
            \
           9(7)
            /
          6(9)
```

好吧。看上去还是一条长链。那可怎么办？我们没办法，毕竟这就是树堆的基线，并且随机数也有问题。~~该死的竖锯接狗……~~



## 威廉树

这是汤浩的树，他的代码称“威廉树”，那么……名字就不用说了。

以下是他的数据结构的似乎是样子是这样的（病~~娇的~~句~~子~~)：

```plaintext
           1
          / \
         |   |
         /   \
        2     3
       / \   / \
      /   \ /   \
     |    | |    |
     4    5 6    7
```

好的，边和点都是有权的。当然，点权初始值是 $0$，但是边权嘛，我们需要一个序列，来让我们这个好吃的数据结构做例子：

```plaintext
8 6 4 3 7 1 5
```

好，那么我们可以定出边权（当然点权我们就隐藏，但是保留相对位置）：

```plaintext
           0
          / \
         14 18
         /   \
        0     0
       / \   / \
      13 20 15 20
      |   | |   |
      0   0 0   0
```

可以看出，对于每个点 $V_x$，以及它的父亲 $V_f$，它们的边权 $E_{V_x,V_f}=\sum_{k=f}^xA_k$。（看得懂吧 :-）而后，我们的前缀和就好算了，可以直接把某个点到根节点的边权加起来。这当然是显然的。

好的那么我们要开始修改点了：啊？等下，等下我先去看[原文](https://www.luogu.com.cn/discuss/638729?page=1&sort=time-d)，好，先不搞了。

# 字符串用数据结构

这里必须补充这个字符串用数据结构，附带提及，存储字符串的也是一种数据结构。

## KMP

这个东西最容易，因为它仅仅是一个匹配字符串的东西。

本来对于字符串的匹配可以直接布鲁特福斯，对，例如

```plaintext
abababcaabaabcbbabbcba
aba||||||||||||||||||| +
 aba||||||||||||||||||
  aba||||||||||||||||| +
   aba||||||||||||||||
    aba|||||||||||||||
     aba||||||||||||||
      aba|||||||||||||
       aba||||||||||||
        aba||||||||||| +
         aba||||||||||
          aba|||||||||
           aba||||||||
            aba|||||||
             aba||||||
              aba|||||
               aba||||
                aba|||
                 aba||
                  aba|
                   aba
(20)
```

不幸的是被浪费的比较次数似乎有点多。怎么办？这时 KMP 三人（对，他们是三个人，不然这算法就应该是 FSP 了）想出了一招，那就是给字符串加一点点附加信息，我们就给 `abcab` 计算一下它的附加信息：

```plaintext
fail 0 0 1
strg a b a
```

这会让我们的匹配速度大大的加快，就像下面：

```plaintext
abababcaabaabcbbabbcba
aba||||||||||||||||||| +
  aba||||||||||||||||| +
    aba|||||||||||||||
      aba|||||||||||||
       aba||||||||||||
        aba||||||||||| +
          aba|||||||||
           aba||||||||
             aba||||||
              aba|||||
               aba||||
                aba|||
                  aba|
                   aba
14
```

那么这个 fail 是拿来干嘛的呢？我们可以用 `ababa` 试试：

```plaintext
fail 0 0 1 2 3
strg a b a b a
```

可以看出，fail 是某个字符串在某个前缀的子字符串的最长的不为原前缀字符串的**相等前后缀的长度。**

那么这个 fail 的定义如此的奇怪可以干什么呢？上面就可以看出，fail 指示了我们应当如何移动原字符串，如果已经匹配了一段，并且栽在了某个倒霉的字符上，那么我们就把它移动字符串长度减去该字符对应位置的 fail 的大小，从而达到不回退的效果，进而简化我们的比较和判断的次数。

那么 fail 该如何求？

前面说了，fail 的定义是某个字符串在某个前缀的子字符串的最长的不为原前缀字符串的相等前后缀的长度。既然这样，我们就布鲁特福斯一下 fail，怎么样？——不怎么样。

我们其实还是可以通过递推求 fail 的，例如我们先跳过 `abacabab` 的无用步骤，我们就可以得到如下的初始值：

```plaintext
fail 0 0
strg a b a c a b a b
```

而后，我们看到了一个好东西——第三个字符和第一个字符相等！我们就有

```plaintext
     -----
fail 0 0 1
strg a b a c a b a b
```

不幸的是后面又废掉了，于是我们只好

```plaintext
fail 0 0 1 0
strg a b a c a b a b
```

现在又有相等了！加上 1，我们就有

```plaintext
           --
fail 0 0 1 0 1
strg a b a c a b a b
```

好，而后还是相等，大胜利！我们就再加上 1：


```plaintext
             -----
fail 0 0 1 0 1 2 3
strg a b a c a b a b
```

但是最后一个字符情况却急转直下。它不相等，但是看上去我们不太可能通过非布鲁特福斯的方法求到解，但是——别忘了，此时我们还有前面的 fail 呢！那么，我们就可以从前面的 `aba` 的 fail 往后转移，既然 `aba` 的 fail 为 1，那么，我们就看看它的下一个字符相不相同，我们就有


```plaintext
           |-------|
fail 0 0 1 0 1 2 3 2
strg a b a c a b a b
```

好，完工！值得一提的是，你不需要背会 KMP，因为它虽然断却很难记忆，推荐使用下面的 AC 自动机。

## Trie 树

Trie 树就是所谓的字典树，它通过把词按照字母丢进 Trie 树来存储单词，例如下面字符串集合

```plaintext
he
she
hers
it
its
```

用 Trie 表述就如下所示（其中 `0` 表示根节点）：

```plaintext
       0
     +-+-+
     h s i
   e-+ | |
   |   h t
   r   | |
   |   e s
   s
```

请注意在 Trie 树中我们会专门标记字符串的结尾以保证不会漏掉某个幸运的字符串。