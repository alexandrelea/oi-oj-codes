标题：部分数据结构

# 线性数据结构

线性数据结构的最直接的两个结构就是数组和链表。

数组就是一排数字连着存储，链表就是只保存通往上一个或下一个数据的节点和当前节点的数据。

众所周知，数组可以直接通过下标访问数据，而链表需要许多便利；但是如果删除或添加数据，如果数组的话就需要大规模移动数据，链表就可以直接修改上一个或下一个数据在哪里，直接丢弃不需要的数据。

## 栈和队列

栈和队列都非常简单，可以通过数组和链表直接实现。

栈，就是只允许数据有一个出入口，而队列则是两个。

队列需要明确数据出入的出入口（对，数据由队头弹出，由队尾进入，并且存在数据可以从首尾两端进出的队列），而栈只需要栈顶直接进行数据压入和弹出。

递归时采用的数据结构是栈。

通常在实现队列时为了节省空间可以使用循环下标的队列。

# 树型数据结构

~~该死的树！我发泄完了。~~

## 基本的树

基本的树非常简单，基本就是一个父级节点接上多个子节点，如果不固定根节点的话这棵树甚至可能是多种形状，不过其拓扑结构是一致的。

一种极为特殊的树是二叉树，因为所有的父级节点最多只能有两个子节点。

通常对于树的实现有链式法和下表固定计算法。由于后者的空间浪费较大，故而在采用完全二叉树的数据结构中普遍应用，而链式法可以动态开点。

## 堆

堆分为大根堆和小根堆两种，其子节点都大于或者小于其父节点。我不明白的是，小根堆的子节点都大于父节点，而大根堆的子节点都小于父节点。

这个算法可以通过 $\mathrm O(\log n)$ 来插入或者删除元素，因此是多种算法中快速求最大值的好东西。

由于堆的优良性质，优先队列就以堆为内里。因而，我们可以使用下面的方式定义大根堆/小根堆：

```cpp
priority_queue<int,vector<int>,less<int>> pq; //小根堆
priority_queue<int,vector<int>,greater<int>> pq; //大根堆
```

当然，使用 pbds 也不是不行。

## Feswick树